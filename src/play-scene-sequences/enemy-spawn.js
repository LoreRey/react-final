import gameAttributes from "../game-attributes.js";

export default function() {
	// Increases the number of enemies to spawn as the game goes on. Incerases by a rate of 1 every minute
	let numberOfEnemies =
		Math.floor((new Date() - this.vars.startTime) / 60000) + 1;
	let step = 0;

	while (step < numberOfEnemies) {
		let path = [];
		let curve;
		let points;
		let xOrY;
		let enemyPath;
		let xCoord;
		let yCoord;
		let leftOrRight;

		// Use a timeout to stagger the enemy spawns as they start to spawn in groups
		setTimeout(() => {
			// Creates 6 to 12 random points on the screen for the enemy to travel between
			const createPath = (x, y) => {
				points = [x, y];

				for (
					let point = 0;
					point < Math.floor(Math.random() * (12 - 6) + 6);
					point++
				) {
					points.push(Math.random() * gameAttributes.gameWidth);
					points.push(Math.random() * gameAttributes.gameHeight);
				}

				points.push(gameAttributes.gameWidth);
				points.push(Math.random() * gameAttributes.gameHeight);

				curve = new Phaser.Curves.Spline(points);
				return curve;
			};

			// Determines whether to spawn the enemy on the top, left, or right edge. Then selects a random spot along that edge and passes that as the initial point in the createPath() function.
			xOrY = Math.floor(Math.random() * Math.floor(2));
			if (xOrY === 0) {
				xCoord = Math.floor(
					Math.random() * Math.floor(gameAttributes.gameWidth)
				);
				yCoord = 0;
				enemyPath = createPath(xCoord, yCoord);
			} else {
				yCoord = Math.floor(
					Math.random() * Math.floor(gameAttributes.gameHeight)
				);
				leftOrRight = Math.floor(Math.random() * Math.floor(2));
				if (leftOrRight === 0) {
					xCoord = 0;
					enemyPath = createPath(xCoord, yCoord);
				} else {
					xCoord = gameAttributes.gameWidth;
					enemyPath = createPath(xCoord, yCoord);
				}
			}

			// Creates the enemy at the first point in the array of generated by createPath().
			let enemy = this.entities.enemies.create(
				enemyPath.points[0].x,
				enemyPath.points[0].y,
				"falcon"
			);

			// Animates the enemy spawn
			enemy.anims.play("falconFly");
			enemy.setCollideWorldBounds(true);

			// Set a timeline path for the enemy to move along
			for (let i = 1; i < enemyPath.points.length; i++) {
				path.push({
					x: enemyPath.points[i].x,
					y: enemyPath.points[i].y
				});
			}

			// Tells the enemy to return to their initial point to make a seemless loop
			path.push({
				x: enemyPath.points[0].x,
				y: enemyPath.points[0].y
			});

			// Creates the timeline for the enemy to follow
			let enemyTimeline = this.tweens.timeline({
				targets: enemy,
				duration: 2000,
				loop: -1,
				ease: "Sine.easeInOut",
				tweens: path
			});
		}, step * 1500);
		step++;
	}
}
